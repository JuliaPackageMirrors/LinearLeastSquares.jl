===============
LSQ.jl Examples
===============

This tutorial showcases LSQ.jl through a few involved examples of linearly
constrained least squares problems.
The plots generated by the following examples use the PyPlot package.
Instructions for installing PyPlot can be found `here <https://github.com/stevengj/PyPlot.jl>`_.

Regression
==========
Regression is the problem of trying to fit a function to some data.
In this example, we will frame some simple regression problems as
unconstrained least squares problems for LSQ.jl to solve.
The files for this example can be found `here <https://github.com/davidlizeng/LSQ.jl/tree/master/examples/simple_lin_and_quad_reg>`_.

In this problem, we are given n points, represented by two n-by-1 vectors, ``x_data`` and ``y_data``. The x and y coordinates of the i-th point are given by the i-th entries of ``x_data`` and ``y_data``, respectively.

We'll start by visualizing the data to get a better sense of the problem at hand.
In a Julia shell, run the following code:

  .. code-block:: none

    include("data.jl");

If the PyPlot package is installed, the following graph of the data will appear

  .. image:: data.png

Linear Regression
-----------------
We will first try to fit a line to the data. A general function for a line is

  .. math::
    f(x) = \mbox{offset} +  \mbox{slope} \cdot x

where :math:`\mbox{slope}` and :math:`\mbox{offset}` are scalar quantities that we pick to determine the line.
We would like to pick :math:`\mbox{slope}` and :math:`\mbox{offset}` so that our data points lie "close" to
our line. For a point with coordinates :math`x` and :math:`y` the residual between the point
and our line is defined as

  .. math::

    \mbox{residual}(x, y) = f(x) - y

One reasonable way to measure how good the line fits the data is to
sum the squares of the residuals between each point in the data and the line.
Using this measurement as "goodness of fit", we would like to choose :math:`\mbox{slope}`
and :math:`\mbox{offset}` to minimize this quantity.

We can now frame this problem in Julia code and solve our problem using LSQ.jl:

  .. code-block:: none

    slope = Variable();
    offset = Variable();
    optval = minimize!(sum_squares(offset .+ x_data * slope - y_data));
    println("Slope = $(slope.value[1, 1]), offset = $(offset.value[1, 1])");

To see a plot of the best fitting line, run:

  .. code-block:: none

    include("linear_regression.jl");

  .. image:: linear.png

Quadratic Regression
--------------------
A line is probably not the best function to fit to this data. Instead, let's try
to fit a quadratic function, which has the form:

  .. math::
    f(x) = \mbox{offset} + \mbox{linear_coeff} \cdot x + \mbox{quadratic_coeff} \cdot x ^ 2

We have now introduced a new quadratic term, along with a new coefficient.
The same residual function from the linear regression example can still be used here,
and similarly, we can measure how good the quadratic function fits the data
by summing the squares of the residuals between each point in the data and the
quadratic.

The Julia code to solve this problem using LSQ.jl is the following:

  .. code-block:: none

    quadratic_coeff = Variable();
    linear_coeff = Variable();
    offset = Variable();
    optval = minimize!(sum_squares(offset + x_data * linear_coeff + x_data .^ 2 * quadratic - y_data));

To see a plot of the best fitting line, run:

  .. code-block:: none

    include("quadratic_regression.jl");

  .. image:: quadratic.png

A much better fit than the line!


Control
=======
One common application of linearly constrained least squares is control, i.e.,
planning the motion of an object. For our example, we want to determine what
forces to apply to an object with some initial position and velocity to bring it to
rest at a final position over some amount of time.

We can simplify the problem by adding a condition that we can only apply constant
forces over fixed length intervals of time, and
that we will have exactly :math:`T` intervals of time, each :math:`h` seconds in length.
Therefore, at each time interval :math:`t`, we have three unknown quantites:
the constant force applied during that interval :math:`f(t)`, the velocity of the object at
the beginning of the interval :math:`v(t)`, and the position of the object at the beginning of
the interval :math:`p(t)`. By the basic laws of physics, these variables must satisfy:

  .. math::
    \begin{align*}
      p(t+1) &= p(t) + h \cdot v(t) \\
      v(t+1) &= v(t) + (h/\mbox{mass}) \cdot f(t) - \mbox{drag} \cdot v(t)
    \end{align*}

where :math:`\mbox{mass}` and :math:`\mbox{drag}` are constants for the mass of the object and the drag
coefficient of the fluid the object is moving in.

Additionally, we have our initial/final position/velocity conditions:

  .. math::
    \begin{align*}
      p(1) &= \mbox{initial_position}\\
      v(1) &= \mbox{initial_velocity}\\
      p(T+1) &= \mbox{final_position}\\
      v(T+1) &= 0
    \end{align*}

Often we would like to satisfy all of these constraints on the motion of the object
while minimizing something along the lines of how much fuel must be conserved to
generate these forces. Usually it is in our best interest to keep the values of the
forces small. It is also possible that we would like to keep the velocity of the
object small as well, perhaps for safety concerns. One reasonable objective to
minimize then would be

  .. math::

    \mbox{objective} = \mu \sum_{t = 1}^{T+1} (v(t))^2 + \sum_{t = 1}^T (f(t))^2

Here :math:`\mu` serves as a parameter to control which part of the objective we
deem more important, keeping the velocity small or keeping the force small.

The code for this problem can be found `here <https://github.com/davidlizeng/LSQ.jl/tree/master/examples/control>`_.
To see a plot of the motion of the object, run the following in a Julia shell:

  .. code-block:: none

    include("control.jl");

  .. image:: control.png

The red path traces the position of the object over the time, while the black
arrows show the forces applied. The blue dots show the initial and final
positions.
