<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LSQ.jl Examples &mdash; LSQ 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="LSQ 0.1 documentation" href="index.html" />
    <link rel="prev" title="LSQ.jl Tutorial" href="lsqjl.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="lsqjl.html" title="LSQ.jl Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">LSQ 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="lsq-jl-examples">
<h1>LSQ.jl Examples<a class="headerlink" href="#lsq-jl-examples" title="Permalink to this headline">¶</a></h1>
<p>This tutorial showcases LSQ.jl through a few involved examples of linearly
constrained least squares problems.
The plots generated by the following examples use the PyPlot package.
Instructions for installing PyPlot can be found <a class="reference external" href="https://github.com/stevengj/PyPlot.jl">here</a>.</p>
<div class="section" id="regression">
<h2>Regression<a class="headerlink" href="#regression" title="Permalink to this headline">¶</a></h2>
<p>Regression is the problem of trying to fit a function to some data.
In this example, we will frame some simple regression problems as
unconstrained least squares problems for LSQ.jl to solve.
The files for this example can be found <a class="reference external" href="https://github.com/davidlizeng/LSQ.jl/tree/master/examples/simple_lin_and_quad_reg">here</a>.</p>
<p>In this problem, we are given n points, represented by two n-by-1 vectors, <tt class="docutils literal"><span class="pre">x_data</span></tt> and <tt class="docutils literal"><span class="pre">y_data</span></tt>. The x and y coordinates of the i-th point are given by the i-th entries of <tt class="docutils literal"><span class="pre">x_data</span></tt> and <tt class="docutils literal"><span class="pre">y_data</span></tt>, respectively.</p>
<p>We&#8217;ll start by visualizing the data to get a better sense of the problem at hand.
In a Julia shell, run the following code:</p>
<div class="highlight-none"><div class="highlight"><pre>include(&quot;data.jl&quot;);
</pre></div>
</div>
<p>If the PyPlot package is installed, the following graph of the data will appear</p>
<img alt="_images/data.png" src="_images/data.png" />
<div class="section" id="linear-regression">
<h3>Linear Regression<a class="headerlink" href="#linear-regression" title="Permalink to this headline">¶</a></h3>
<p>We will first try to fit a line to the data. A general function for a line is</p>
<div class="math">
\[f(x) = \mbox{offset} +  \mbox{slope} \cdot x\]</div>
<p>where <span class="math">\(\mbox{slope}\)</span> and <span class="math">\(\mbox{offset}\)</span> are scalar quantities that we pick to determine the line.
We would like to pick <span class="math">\(\mbox{slope}\)</span> and <span class="math">\(\mbox{offset}\)</span> so that our data points lie &#8220;close&#8221; to
our line. For a point with coordinates :math`x` and <span class="math">\(y\)</span> the residual between the point
and our line is defined as</p>
<div class="math">
\[\mbox{residual}(x, y) = f(x) - y\]</div>
<p>One reasonable way to measure how good the line fits the data is to
sum the squares of the residuals between each point in the data and the line.
Using this measurement as &#8220;goodness of fit&#8221;, we would like to choose <span class="math">\(\mbox{slope}\)</span>
and <span class="math">\(\mbox{offset}\)</span> to minimize this quantity.</p>
<p>We can now frame this problem in Julia code and solve our problem using LSQ.jl:</p>
<div class="highlight-none"><div class="highlight"><pre>slope = Variable();
offset = Variable();
optval = minimize!(sum_squares(offset .+ x_data * slope - y_data));
println(&quot;Slope = $(slope.value[1, 1]), offset = $(offset.value[1, 1])&quot;);
</pre></div>
</div>
<p>To see a plot of the best fitting line, run:</p>
<blockquote>
<div><div class="highlight-none"><div class="highlight"><pre>include(&quot;linear_regression.jl&quot;);
</pre></div>
</div>
<img alt="_images/linear.png" src="_images/linear.png" />
</div></blockquote>
</div>
<div class="section" id="quadratic-regression">
<h3>Quadratic Regression<a class="headerlink" href="#quadratic-regression" title="Permalink to this headline">¶</a></h3>
<p>A line is probably not the best function to fit to this data. Instead, let&#8217;s try
to fit a quadratic function, which has the form:</p>
<div class="math">
\[f(x) = \mbox{offset} + \mbox{linear_coeff} \cdot x + \mbox{quadratic_coeff} \cdot x ^ 2\]</div>
<p>We have now introduced a new quadratic term, along with a new coefficient.
The same residual function from the linear regression example can still be used here,
and similarly, we can measure how good the quadratic function fits the data
by summing the squares of the residuals between each point in the data and the
quadratic.</p>
<p>The Julia code to solve this problem using LSQ.jl is the following:</p>
<div class="highlight-none"><div class="highlight"><pre>quadratic_coeff = Variable();
linear_coeff = Variable();
offset = Variable();
optval = minimize!(sum_squares(offset + x_data * linear_coeff + x_data .^ 2 * quadratic - y_data));
</pre></div>
</div>
<p>To see a plot of the best fitting line, run:</p>
<div class="highlight-none"><div class="highlight"><pre>include(&quot;quadratic_regression.jl&quot;);
</pre></div>
</div>
<img alt="_images/quadratic.png" src="_images/quadratic.png" />
<p>A much better fit than the line!</p>
</div>
</div>
<div class="section" id="control">
<h2>Control<a class="headerlink" href="#control" title="Permalink to this headline">¶</a></h2>
<p>One common application of linearly constrained least squares is control, i.e.,
planning the motion of an object.</p>
<div class="section" id="hitting-waypoints-terrible-title">
<h3>Hitting Waypoints (Terrible title)<a class="headerlink" href="#hitting-waypoints-terrible-title" title="Permalink to this headline">¶</a></h3>
<p>For our example, we want to determine what
forces to apply to an object with some initial position and velocity to bring it to
rest at a final position over some amount of time.</p>
<p>We can simplify the problem by adding a condition that we can only apply constant
forces over fixed length intervals of time, and
that we will have exactly <span class="math">\(T\)</span> intervals of time, each <span class="math">\(h\)</span> seconds in length.
Therefore, at each time interval <span class="math">\(t\)</span>, we have three unknown quantites:
the constant force applied during that interval <span class="math">\(f(t)\)</span>, the velocity of the object at
the beginning of the interval <span class="math">\(v(t)\)</span>, and the position of the object at the beginning of
the interval <span class="math">\(p(t)\)</span>. By the basic laws of physics, these variables must satisfy:</p>
<div class="math">
\[\begin{split}\begin{align*}
  p(t+1) &amp;= p(t) + h \cdot v(t) \\
  v(t+1) &amp;= v(t) + (h/\mbox{mass}) \cdot f(t) - \mbox{drag} \cdot v(t)
\end{align*}\end{split}\]</div>
<p>where <span class="math">\(\mbox{mass}\)</span> and <span class="math">\(\mbox{drag}\)</span> are constants for the mass of the object and the drag
coefficient of the fluid the object is moving in.</p>
<p>Additionally, we have our initial/final position/velocity conditions:</p>
<div class="math">
\[\begin{split}\begin{align*}
  p(1) &amp;= \mbox{initial_position}\\
  v(1) &amp;= \mbox{initial_velocity}\\
  p(T+1) &amp;= \mbox{final_position}\\
  v(T+1) &amp;= 0
\end{align*}\end{split}\]</div>
<p>Often we would like to satisfy all of these constraints on the motion of the object
while minimizing something along the lines of how much fuel must be conserved to
generate these forces. Usually it is in our best interest to keep the values of the
forces small. It is also possible that we would like to keep the velocity of the
object small as well, perhaps for safety concerns. One reasonable objective to
minimize then would be</p>
<div class="math">
\[\mbox{objective} = \mu \sum_{t = 1}^{T+1} (v(t))^2 + \sum_{t = 1}^T (f(t))^2\]</div>
<p>Here <span class="math">\(\mu\)</span> serves as a parameter to control which part of the objective we
deem more important, keeping the velocity small or keeping the force small.</p>
<p>The code for this problem can be found <a class="reference external" href="https://github.com/davidlizeng/LSQ.jl/tree/master/examples/control">here</a>.
To see a plot of the motion of the object, run the following in a Julia shell:</p>
<div class="highlight-none"><div class="highlight"><pre>include(&quot;control.jl&quot;);
</pre></div>
</div>
<img alt="_images/control.png" src="_images/control.png" />
<p>The red path traces the position of the object over the time, while the black
arrows show the forces applied. The blue dots show the initial and final
positions.</p>
</div>
</div>
<div class="section" id="image-processing">
<h2>Image Processing<a class="headerlink" href="#image-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tomography">
<h3>Tomography<a class="headerlink" href="#tomography" title="Permalink to this headline">¶</a></h3>
<p>Tomography is the process of reconstructing a density distrbution from given
integrals over sections of the distribution. The idea can be best visualized using a
two dimensional black and white image. The density distribution in this case
is how much black ink is used in each pixel.
Now, imagine drawing a red line across the image.
The total amount of black ink covered up by the red line can be thought of
as integrals over the line of the density distrbution. If we draw many, many of these
red lines and record the integral for each, can we use just this information to
reconstruct the original image? This is the very similar to the problem that a device like an
x-ray uses to construct a picture of your internals given only information on how
the radiation waves traveled through your body. It turns out the two dimensional
black and white image scenario can be solved by LSQ.</p>
<p>Suppose there are <span class="math">\(n\)</span> pixels in the picture, each with density value <span class="math">\(x_j\)</span> for <span class="math">\(1 \le j \le n\)</span>,
which are currently unknown.
We also take <span class="math">\(m\)</span> line integrals, where <span class="math">\(m &gt; n\)</span> each with value <span class="math">\(y_i\)</span> for <span class="math">\(1 \le i \le m\)</span>.
We also know how each line passes over which pixels and at what angle. Using this
information, we can represent this problem as</p>
<div class="math">
\[y = Ax\]</div>
<p>Here, <span class="math">\(A\)</span> is a matrix where <span class="math">\(A_{ij}\)</span> represents how much line <span class="math">\(i\)</span>
passes over pixel <span class="math">\(j\)</span>. For example, if the line barely touches the corner of a pixel,
the corresponding value for <span class="math">\(A_{ij}\)</span> would be very small. If the line instead
cross over the pixel straight through the middle, the value for <span class="math">\(A_{ij}\)</span> would be
relatively big.</p>
<p>Anytime we have measurements, there are usually small errors that occur. So a more
accruate model for our problem would be</p>
<div class="math">
\[y = Ax + v \iff v = Ax - y\]</div>
<p>Where the error vector <span class="math">\(v\)</span> is assumed to be small and have zero mean.
It is very reasonable then to try to minimize the sum of squares of the error,
as that would force the resulting <span class="math">\(v\)</span> to have rather small entries,
and center the mean of the entries at <span class="math">\(0\)</span>. Thus our problem becomes:</p>
<div class="math">
\[\begin{split}\begin{array}{ll}\mbox{minimize} &amp; \|v\|_2^2 \end{array} \iff
\begin{array}{ll}\mbox{minimize} &amp; \|Ax - y\|_2^2 \end{array}\end{split}\]</div>
<p>which we recognize as an unconstrained least squares problem; something we can
readily solve in LSQ.jl!</p>
<p>The code and data for this example can be found <a class="reference external" href="https://github.com/davidlizeng/LSQ.jl/tree/master/examples/tomography">here</a>.</p>
<div class="highlight-none"><div class="highlight"><pre>import PyPlot.plt
import PyPlot.cm
using PyPlot
using LSQ

# read in the data
line_mat_x = readdlm(&quot;tux_sparse_x.txt&quot;);
line_mat_y = readdlm(&quot;tux_sparse_y.txt&quot;);
line_mat_val = readdlm(&quot;tux_sparse_val.txt&quot;);
line_vals = readdlm(&quot;tux_sparse_lines.txt&quot;);

img_size = 50
num_pixels = img_size * img_size

line_mat = spzeros(3300, num_pixels);

num_vals = length(line_mat_val)

# build the matrix. The entry at i,j reflects how much line i
# intersects pixel j.
for i in 1:num_vals
  x = int(line_mat_x[i]);
  y = int(line_mat_y[i]);
  line_mat[x + 1, y + 1] = line_mat_val[i];
end

# solve the problem using LSQ.jl
x = Variable(num_pixels)
objective = sum_squares(line_mat * x - line_vals);
optval = minimize!(objective);

plt.imshow(reshape(x.value, img_size,img_size), cmap = get_cmaps()[29])
</pre></div>
</div>
<p>The final result of the tomography will look something like</p>
<img alt="_images/tomography.png" src="_images/tomography.png" />
</div>
</div>
<div class="section" id="machine-learning">
<h2>Machine Learning<a class="headerlink" href="#machine-learning" title="Permalink to this headline">¶</a></h2>
<div class="section" id="binary-classification">
<h3>Binary Classification<a class="headerlink" href="#binary-classification" title="Permalink to this headline">¶</a></h3>
<p>One common problem found in machine learning is the classification of a group of objects into two subgroups.
In this example, we will work with a collection of text documents, that
come from three sources: sports articles, Harry Potter excerpts, and education articles.
The goal will be to classify each document as either a sports article, or
not a sports article. These sources will only have slight overlap in content, e.g, some
education articles may mention sports and of course Harry Potter plays the sport
of Quidditch.</p>
<p>When classifying text documents, one of the most common techniques is to build
a term-by-document frequency matrix <span class="math">\(F\)</span>. That is, <span class="math">\(F_{ij}\)</span>
reflects the frequency of term :math:&#8217;j&#8217; in document <span class="math">\(i\)</span>.
A handful of common preprocessing techniques are used to make this more effective, such
as removing overly common words like &#8220;the&#8221;, removing endings in words like &#8220;ing&#8221;,
converting all nouns to singular forms, removing words that appear in too few documents,
and normalizing frequency counts so that longer documents will not outweight shorter ones.</p>
<p>The documents are then split into a training and testing set. For each document
in the training example, we also label the document with the correct label, in this case,
sports or not sports. Often, the numbers <span class="math">\(1\)</span> and <span class="math">\(-1\)</span> will be used to represent the labels.
One reasonable approach is to model the label of a document as an affine function
of the term frequencies of the document:</p>
<div class="math">
\[\mbox{label}(i) = v + \sum_{j = 1}^n w_jF_{ij}.\]</div>
<p>The goal now is to find a scalar <span class="math">\(v\)</span> and a weight vector <span class="math">\(w\)</span>, where <span class="math">\(w_j\)</span> reflects how
important term <span class="math">\(j\)</span> is in determining the label of the document. In our context, a positive value
means that the term is often seen in sports articles, while a negative value means
the term is often seen in the Harry Potter excerpts or education articles. One reasonable
method of learning <span class="math">\(v\)</span> and <span class="math">\(w\)</span> is to use regularized least squares. We
try to minimize the objective:</p>
<div class="math">
\[\sum_{i = 1}^m  \left(\mbox{label}(i) - v - \sum_{j = 1}^n w_jF_{ij}\right)^2 + \lambda \sum_{j = 1}^n w_j^2\]</div>
<p>The first part of the objective is to ensure that our linear model actually closely
reproduces the labels of our training documents. The second part of the objective
ensures that the components of <span class="math">\(w\)</span> are relatively small. We want our document
classifier to work on other text documents, not just the ones we trained on. If
the components of <span class="math">\(w\)</span> are large, then slight changes in term frequecies of
documents would mean drastic changes in the value of the affine function, to the point
where the sign could change. Keeping <span class="math">\(w\)</span> small allows our model to behave
better on documents not in the training set. The regularization parameter <span class="math">\(\lambda\)</span>
allows us to control how much we should prioritize keeping <span class="math">\(w\)</span> small versus
how close the affine function should fit the labels.</p>
<p>Here is the LSQ.jl code:</p>
<div class="highlight-none"><div class="highlight"><pre>include(&quot;MatrixMarket.jl&quot;)
using MatrixMarket
using LSQ

# read in the data
A = full(MatrixMarket.mmread(&quot;largeCorpus.mtx&quot;));

# extract the classes of each document
classes = A[:,1];
# TODO: modify classes so that 4 5 6 are 1 2 3
classes[classes .&gt; 3] = classes[classes .&gt; 3] - 3;
A = A[:, 2:end];

# split into train/test
numData = size(A, 1);
data = randperm(numData);
ind = floor(numData*0.7);
training = data[1:ind];
test = data[ind+1:end];
trainDocuments = A[training,:];
trainClasses = classes[training,:];
testDocuments = A[test,:];
testClasses = classes[test,:];

# change all other than sports to -1 (sports is 1)
holdClass = 1;
trainClasses[trainClasses .!= holdClass] = -1;
trainClasses[trainClasses .== holdClass] = 1;
testClasses[testClasses .!= holdClass] = -1;
testClasses[testClasses .== holdClass] = 1;

# build the problem and solve with LSQ
lambda = 100;
w = Variable(size(A, 2));
v = Variable();
objective = sum_squares(trainDocuments * w + v - trainClasses) + lambda * sum_squares(w);
optval = minimize!(objective);

# calculate training error
yhat = sign(trainDocuments * w.value .+ v.value);
trainCE =  1/size(trainClasses,1)*sum(trainClasses .!= yhat)

# calculate performance of our classifier on the test set
yhat2 = sign(testDocuments * w.value .+ v.value);
testCE = 1/size(testClasses,1)*sum(testClasses .!= yhat2)
</pre></div>
</div>
</div>
</div>
<div class="section" id="time-series-analysis">
<h2>Time Series Analysis<a class="headerlink" href="#time-series-analysis" title="Permalink to this headline">¶</a></h2>
<p>A time series is a sequence of data points, each associated with a time. The time series
is usually organized in increasing order based on time, and often the times are
regularly spaced. In our example, we will work with a time series of daily
temperatures in the city of Melbourne, Australia over a period of a few years.
Heres a picture of the temperature data:</p>
<img alt="_images/melbourne.png" src="_images/melbourne.png" />
<div class="section" id="finding-trends">
<h3>Finding Trends<a class="headerlink" href="#finding-trends" title="Permalink to this headline">¶</a></h3>
<p>The picture motivates a decomposition of the time series. We can easily see that
there is a long term up and down in the temperature over the course of each year.
On top of that there are short term fluctuations in temperature that cause
each year to look slightly different.
Using our least squares methods, we will try to find a time series
that repeats itself every year that best captures the seasonal up and downs in
temperature, and separate this from the daily fluctuations.</p>
<p>We can represent the seasonal trend in temperature as a vector where the <span class="math">\(i\)</span>-th
entry denotes the temperature on the <span class="math">\(i\)</span>-th day.
To force this trend to repeat yearly, we simply want</p>
<div class="math">
\[\mbox{seasonal}(i) = \mbox{seasonal}(i + 365)\]</div>
<p>for each applicable <span class="math">\(i\)</span>. This can easily be encapsulated in linear
equality constraints our sesonal temperature variable.</p>
<p>We also want the seasonal trend to have two more properties. The first is that
the seasonal trend should be relatively close to the actual temperature of that day.
Short term fluctuations in temperature can only cause so much deviation.
The second is that the change in temperature of the seasonal trend from day to
day should be relatively small. Sudden jumps in temeprature are better described
by the short term fluctuations than the long term trends. Therefore, we would like
to minimize the value of the following objective</p>
<div class="math">
\[\sum_{i = 1}^n (\mbox{seasonal}(i) - \mbox{actual}(i))^2 + \lambda \sum_{i = 2}^n(\mbox{seasonal}(i) - \mbox{seasonal}(i - 1))^2\]</div>
<p>where <span class="math">\(\lambda\)</span> is the smoothing parameter. The larger :math`lambda` is, the more
we favor the seasonal trend to be smooth, i.e., the seasonal trend should have small
change from day to day.</p>
<p>The following code uses LSQ.jl to find and plot the seasonal trend:</p>
<div class="highlight-none"><div class="highlight"><pre># read in the data
temps = readdlm(&quot;melbourne_temps.txt&quot;, &#39;,&#39;);
n = size(temps, 1);

# enforce the seasonal trend to be the same every year
seasonal = Variable(n);
eq_constraints = EqConstraint[]
for i in 365 + 1 : n
  eq_constraints += seasonal[i] == seasonal[i - 365];
end

# build the objective and solve the problem
smoothing = 3;
smooth_objective = sum_squares(seasonal[1 : n - 1] - seasonal[2 : n]);
optval = minimize!(sum_squares(temps - seasonal) + smoothing * smooth_objective, eq_constraints);
residuals = temps - seasonal.value;

# plot seasonal trend
plt.figure(1)
plt.plot(temps)
plt.plot(seasonal.value, color=&quot;r&quot;, alpha=0.5)
plt.title(&quot;Seasonal Fit of Data&quot;)
plt.xlim([0, n])
</pre></div>
</div>
<img alt="_images/seasonal_fit.png" src="_images/seasonal_fit.png" />
</div>
<div class="section" id="modeling-fluctuations">
<h3>Modeling Fluctuations<a class="headerlink" href="#modeling-fluctuations" title="Permalink to this headline">¶</a></h3>
<p>The next step is to model out short term fluctuations. We subtract our seasonal
trend from the actual temperatures to get our residual temperatures, i.e., deviations from the
seasonal trend temperatures. A reasonable hypothesis is that the residual temperature
today depends on some linear combination of the residual temperatures over the last
five days. If the last couple of days were abnormably hot, chances are today will also be pretty hot.
Such a model is called an autoregressive model. We are essentially trying to fit the data
as a function of other parts of the data itself.
Therefore, we want to find a vector of coefficients <span class="math">\(a\)</span> such that</p>
<div class="math">
\[\mbox{residual}(i) \approx \sum_{j = 1}^5 a_j \mbox{residual}(i - j)\]</div>
<p>This can be done by simply minimizing the following sum of squares objective</p>
<div class="math">
\[\sum_{i = 6}^n \left(\mbox{residual}(i) - \sum_{j = 1}^5 a_j \mbox{residual}(i - j)\right)^2\]</div>
<p>The following LSQ.jl code solves this problem and plots our autoregressive model
against the actual residual temperatures:</p>
<div class="highlight-none"><div class="highlight"><pre># Generate the residuals matrix
ar_len = 5;
residuals_mat = residuals[ar_len : n - 1];
for i = 1:ar_len - 1
  residuals_mat = [residuals_mat residuals[ar_len - i : n - i - 1]];
end

# Solve autoregressive problem
ar_coef = Variable(ar_len);
optval2 = minimize!(sum_squares(residuals_mat * ar_coef - residuals[ar_len + 1 : end]));

# plot autoregressive fit of daily fluctuations
plt.figure(2)
plt.plot(residuals[ar_len + 1 : end], color=&quot;g&quot;, alpha=1)
plt.plot(residuals_mat * ar_coef.value, color=&quot;r&quot;, alpha=0.5)
plt.title(&quot;Autoregressive Fit of Residuals&quot;)
plt.xlim([0, n])
</pre></div>
</div>
<img alt="_images/ar_fit.png" src="_images/ar_fit.png" />
<p>Now, we can add our autoregressive model for the residual temperatures to our
seasonal trend to get an overall model for the daily temperatures in the city of
Melbourne:</p>
<div class="highlight-none"><div class="highlight"><pre># plot final fit of data
total_estimate = seasonal.value
total_estimate[ar_len + 1 : end] += residuals_mat * ar_coef.value
plt.figure(3)
plt.plot(temps)
plt.plot(total_estimate, color=&quot;r&quot;, alpha=0.5)
plt.title(&quot;Total Fit of Data&quot;)
plt.xlim([0, n])
</pre></div>
</div>
<img alt="_images/total_fit.png" src="_images/total_fit.png" />
<p>Our model does a pretty decent job capturing both the long term and short term
trends in temperatures.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">LSQ.jl Examples</a><ul>
<li><a class="reference internal" href="#regression">Regression</a><ul>
<li><a class="reference internal" href="#linear-regression">Linear Regression</a></li>
<li><a class="reference internal" href="#quadratic-regression">Quadratic Regression</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control">Control</a><ul>
<li><a class="reference internal" href="#hitting-waypoints-terrible-title">Hitting Waypoints (Terrible title)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#image-processing">Image Processing</a><ul>
<li><a class="reference internal" href="#tomography">Tomography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#machine-learning">Machine Learning</a><ul>
<li><a class="reference internal" href="#binary-classification">Binary Classification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#time-series-analysis">Time Series Analysis</a><ul>
<li><a class="reference internal" href="#finding-trends">Finding Trends</a></li>
<li><a class="reference internal" href="#modeling-fluctuations">Modeling Fluctuations</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="lsqjl.html"
                        title="previous chapter">LSQ.jl Tutorial</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/lsqjl_examples.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="lsqjl.html" title="LSQ.jl Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">LSQ 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Keegan Go, Karanveer Mohan, David Zeng.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>